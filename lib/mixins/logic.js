/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./logic.macro.js#52e945db42d6b854d12713f5697f3811445fce83
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i, re } from '@bablr/boot';
import { Node } from '@bablr/helpers/decorators';
const buildOperatorPattern = operators => re`/${[...operators].map(op => re.Alternative(re.Sequence([...op].map(chr => re.Literal(chr)))))}/`;
export const unaryExpressionOperators = new Set(['+', '-', '~', 'typeof', 'void', 'delete']);
export const unaryOperatorPattern = buildOperatorPattern(unaryExpressionOperators);
export const binaryExpressionOperators = new Set(['+', '-', '*', '**', '/', '&&', '||', '&', '|', '^', '==', '===', '!=', '!==', '<', '<=', '>', '>=', 'instanceof', 'in', '<<', '>>']);
export const binaryOperatorPattern = buildOperatorPattern(binaryExpressionOperators);
export const mixin = Base => {
  var _initProto;
  return class ES3LogicGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[Node, 2, "UnaryExpression"], [Node, 2, "BinaryExpression"]], []).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *UnaryExpression() {
      yield i`eat(<*Punctuator ${unaryOperatorPattern}> 'sigilToken')`;
      yield i`eat(<+Expression> 'argument')`;
    }
    *BinaryExpression() {
      yield i`eat(<+Expression> 'left')`;
      yield i`eat(<*Punctuator ${binaryOperatorPattern}> 'sigilToken')`;
      yield i`eat(<+Expression> 'right')`;
    }
  };
};