/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./logic.macro.js#199a3b73d1b37357442cb151a200bdd783510e66
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i, re } from '@bablr/boot';
import { Attributes, Node } from '@bablr/helpers/decorators';

// problem: the concrete syntax is only right in some contexts (spans)
const escaped = {
  '\\': re.Character`\\`,
  '/': re.Character`\/`,
  '(': re.Character`\(`,
  ')': re.Character`\)`,
  '{': re.Character`\{`,
  '}': re.Character`\}`,
  '+': re.Character`\+`,
  '*': re.Character`\*`
};
const buildOperatorPattern = operators => re`/${operators.map(op => re.Alternative`${[...op].map(chr => {
  if ('\\/(){}+*^$?|'.includes(chr)) {
    return escaped[chr];
  } else {
    return re.Character({
      raw: [chr]
    });
  }
})}`)}/`;
const assignmentOperators = ['=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '^=', '|='];
const assignmentOperatorPattern = buildOperatorPattern(assignmentOperators);
const unaryPrefixOperators = ['typeof', 'void', 'delete', '++', '--', '+', '-', '!', '~'];
const unaryPrefixOperatorPattern = buildOperatorPattern(unaryPrefixOperators);
const unaryPostfixOperators = ['++', '--'];
const unaryPostfixOperatorPattern = buildOperatorPattern(unaryPostfixOperators);
const binaryExpressionPowerRank = [['||'], ['&&'], ['|'], ['^'], ['&'], ['===', '==', '!==', '!='], ['<=', '<', '>=', '>', 'instanceof', 'in'], ['>>>', '<<', '>>'], ['+', '-'], ['%', '*', '/']];
export const getBinaryOperatorPattern = power => {
  return buildOperatorPattern(binaryExpressionOperators);
};
export const mixin = Base => {
  var _dec, _initProto;
  return _dec = Attributes(['power']), class ES3LogicGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[Node, 2, "UnaryExpression"], [[_dec, Node], 2, "BinaryExpression"], [Node, 2, "AssignmentExpression"]], []).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *Expression({
      attrs
    }) {
      const {
        power = 18
      } = attrs;
      if (power >= 5) {
        yield i`eat(<LogicExpression power=${power}>)`;
      }
    }
    *LogicExpression({
      attrs
    }) {
      const {
        power = 17
      } = attrs;
      let res;
      if (power >= 17) {
        res = yield i`eat(<AssignmentExpresion power=4>)`;
      } else if (power >= 7) {
        res = yield i`eat(<BinaryExpression power=${power}>)`;
      } else if (power >= 5) {
        res = yield i`eat(<UnaryExpression power=${power}>)`;
      }
      const opPower = res.attributes.power;
      return i`shiftMatch(<+Expression power=${opPower}>)`;
    }
    *UnaryExpression() {
      yield i`eat(<*Punctuator ${unaryOperatorPattern}> 'sigilToken')`;
      yield i`eat(<+Expression> 'argument')`;
    }
    *BinaryExpression({
      attrs
    }) {
      yield i`eat(<+Expression power=${power - 1}> 'left')`;
      yield i`eat(<*Punctuator ${getBinaryOperatorPattern(leftPower + 1)}> 'sigilToken')`;
      yield i`eat(<+Expression power=${opPower - 1}> 'right')`;
    }
    *AssignmentExpression() {
      yield i`eat(<*Identifier> 'left')`;
      yield i`eat(<*Punctuator ${assignmentOperatorPattern}> 'sigilToken')`;
      yield i`eat(<+Expression power=${opPower - 1}> 'right')`;
    }
  };
};