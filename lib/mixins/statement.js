/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./statement.macro.js#e211aa18666f33d8f68a54b5fea2023153f94b22
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i } from '@bablr/boot';
import { AllowEmpty, CoveredBy, Node } from '@bablr/helpers/decorators';
export const mixin = Base => {
  let _initProto, _EmptyStatementDecs, _BlockStatementDecs, _IfStatementDecs, _WhileStatementDecs, _DoWhileStatementDecs, _SwitchStatementDecs, _ForStatementDecs, _ForInStatementDecs, _LabeledStatementDecs, _BreakStatementDecs, _ContinueStatementDecs;
  return class ES3StatementGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[Node, 2, "Program"], [[AllowEmpty, Node], 2, "ExpressionStatement"], [AllowEmpty, 2, "Statement"], [_EmptyStatementDecs, 2, "EmptyStatement"], [_BlockStatementDecs, 2, "BlockStatement"], [_IfStatementDecs, 2, "IfStatement"], [_WhileStatementDecs, 2, "WhileStatement"], [_DoWhileStatementDecs, 2, "DoWhileStatement"], [_SwitchStatementDecs, 2, "SwitchStatement"], [Node, 2, "SwitchCase"], [_ForStatementDecs, 2, "ForStatement"], [_ForInStatementDecs, 2, "ForInStatement"], [_LabeledStatementDecs, 2, "LabeledStatement"], [_BreakStatementDecs, 2, "BreakStatement"], [_ContinueStatementDecs, 2, "ContinueStatement"]], [], 0, void 0, Base).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *[(_EmptyStatementDecs = [CoveredBy('Statement'), AllowEmpty, Node], _BlockStatementDecs = [CoveredBy('Statement'), Node], _IfStatementDecs = [CoveredBy('Statement'), Node], _WhileStatementDecs = [CoveredBy('Statement'), Node], _DoWhileStatementDecs = [CoveredBy('Statement'), Node], _SwitchStatementDecs = [CoveredBy('Statement'), Node], _ForStatementDecs = [CoveredBy('Statement'), Node], _ForInStatementDecs = [CoveredBy('Statement'), Node], _LabeledStatementDecs = [CoveredBy('Statement'), Node], _BreakStatementDecs = [CoveredBy('Statement'), Node], _ContinueStatementDecs = [CoveredBy('Statement'), Node], "Program")]() {
      yield i`eat(<StatementList /> 'body[]')`;
    }
    *StatementList() {
      do {
        yield i`eat(<Statement />)`;
      } while ((yield i`eatMatch(<*Punctuator ';' /> 'separatorTokens[]')`) && (yield i`match(/./s)`));
    }
    *ExpressionStatement() {
      yield i`eat(<Expression /> 'expression')`;
    }
    *Statement() {
      yield i`eat(<Any /> null [
        <EmptyStatement /;|$/ />
        <BlockStatement '{' />
        <IfStatement 'if' />
        <WhileStatement 'while' />
        <DoWhileStatement 'do' />
        <SwitchStatement 'switch' />
        <LoopStatement 'for' />
        <ExpressionStatement />
      ])`;
    }
    *EmptyStatement() {}
    *BlockStatement() {
      yield i`eat(<*Punctuator '{' balanced='}' /> 'openToken')`;
      yield i`eat(<StatementList /> 'body[]')`;
      yield i`eat(<*Punctuator '}' balancer /> 'closeToken')`;
    }
    *IfStatement() {
      yield i`eat(<*Keyword 'if' /> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openHeaderToken')`;
      yield i`eat(<Expression /> 'test')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeHeaderToken')`;
      yield i`eat(<Statement /> 'consequent')`;
      if (yield i`eatMatch(<*Keyword 'else' /> 'alternateSigilToken')`) {
        yield i`eat(<Statement /> 'alternate')`;
      } else {
        yield i`eat(null 'alternate')`;
      }
    }
    *WhileStatement() {
      yield i`eat(<*Keyword 'while' /> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openHeaderToken')`;
      yield i`eat(<Expression /> 'test')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeHeaderToken')`;
      yield i`eat(<Statement /> 'body')`;
    }
    *DoWhileStatement() {
      yield i`eat(<*Keyword 'do' /> 'sigilToken')`;
      yield i`eat(<Statement /> 'body')`;
      yield i`eat(<*Keyword 'while' /> 'footerSigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openFooterToken')`;
      yield i`eat(<Expression /> 'test')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeFooterToken')`;
    }
    *SwitchStatement() {
      yield i`eat(<*Keyword 'switch' /> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openDiscriminantToken')`;
      yield i`eat(<Expression /> 'discriminant')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeDiscriminantToken')`;
      yield i`eat(<*Punctuator '{' balanced='}' /> 'openCasesToken')`;
      yield i`eatMatch(<SwitchCase /(case|default)\b/ /> 'cases[]')`;
      yield i`eat(<*Punctuator '}' balancer /> 'closeCasesToken')`;
    }
    *SwitchCase({
      intrinsicValue,
      ctx
    }) {
      switch (ctx.sourceTextFor(intrinsicValue)) {
        case 'case':
          yield i`eat(<*Keyword 'case' /> 'sigilToken')`;
          yield i`eat(<Expression /> 'condition')`;
          break;
        case 'default':
          yield i`eat(<*Keyword 'default' /> 'sigilToken')`;
          yield i`eat(null 'condition')`;
          break;
        default:
          yield i`fail()`;
          break;
      }
      yield i`eat(<*Punctuator ':' /> 'bodySeparatorToken')`;
      while (yield i`match(/./)`) yield i`eat(<Statement /> 'statements[]')`;
    }
    *LoopStatement() {
      // This might have been called ForStatement, but that name was already in use
      throw new Error('not implemented');
    }
    *ForStatement() {
      yield i`eat(<*Keyword 'for' /> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration /> 'init')`)) {
        yield i`eatMatch(<Expression /> 'init')`;
      }
      yield i`eat(<*Punctuator ';' /> 'testSeparatorToken')`;
      yield i`eatMatch(<Expression /> 'test')`;
      yield i`eat(<*Punctuator ';' /> 'updateSeparatorToken')`;
      yield i`eatMatch(<Expression /> 'update')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeHeaderToken')`;
      yield i`eat(<Statement /> 'body')`;
    }
    *ForInStatement() {
      yield i`eat(<*Keyword 'for' /> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')' /> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration /> 'left')`)) {
        yield i`eatMatch(<Expression /> 'left')`;
      }
      yield i`eat(<*Keyword 'in' /> 'iterationSigilToken')`;
      yield i`eatMatch(<Expression /> 'right')`;
      yield i`eat(<*Punctuator ')' balancer /> 'closeHeaderToken')`;
      yield i`eat(<Statement /> 'body')`;
    }
    *LabeledStatement() {
      yield i`eat(<*Identifier /> 'label')`;
      yield i`eat(<*Puncuator ':' /> 'sigilToken')`;
      yield i`eat(<*Statement /> 'body')`;
    }
    *BreakStatement() {
      yield i`eat(<*Keyword 'break' /> 'sigilToken')`;
      yield i`eatMatch(<*Identifier /> 'label')`;
    }
    *ContinueStatement() {
      yield i`eat(<*Keyword 'continue' /> 'sigilToken')`;
      yield i`eatMatch(<*Identifier /> 'label')`;
    }
  };
};