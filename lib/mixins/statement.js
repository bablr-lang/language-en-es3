/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./statement.macro.js#e01cb95bcbef56c57417d91ee88603b6c063ac8d
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i } from '@bablr/boot';
import { Node } from '@bablr/helpers/decorators';
export const mixin = Base => {
  var _initProto;
  return class ES3StatementGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[Node, 2, "BlockStatement"], [Node, 2, "ExpressionStatement"], [Node, 2, "IfStatement"], [Node, 2, "WhileStatement"], [Node, 2, "DoWhileStatement"], [Node, 2, "SwitchStatement"], [Node, 2, "SwitchCase"], [Node, 2, "ForStatement"], [Node, 2, "ForInStatement"], [Node, 2, "LabeledStatement"], [Node, 2, "BreakStatement"], [Node, 2, "ContinueStatement"]], []).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *BlockStatement() {
      yield i`eat(<*Punctuator '{' balanced='}'> 'openBlockToken')`;
      while (yield i`match(/./)`) yield i`eat(<Statement> 'body[]')`;
      yield i`eat(<*Punctuator '}' balancer> 'closeBlockToken')`;
    }
    *ExpressionStatement() {
      yield i`eat(<Expression> 'expression')`;
    }
    *IfStatement() {
      yield i`eat(<*Keyword 'if'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'consequent')`;
      if (yield i`eatMatch(<*Keyword 'else'> 'alternateSigilToken')`) {
        yield i`eat(<Statement> 'alternate')`;
      } else {
        yield i`eat(null 'alternate')`;
      }
    }
    *WhileStatement() {
      yield i`eat(<*Keyword 'while'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *DoWhileStatement() {
      yield i`eat(<*Keyword 'do'> 'sigilToken')`;
      yield i`eat(<Statement> 'body')`;
      yield i`eat(<*Keyword 'while'> 'footerSigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openFooterToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeFooterToken')`;
    }
    *SwitchStatement() {
      yield i`eat(<*Keyword 'switch'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openDiscriminantToken')`;
      yield i`eat(<Expression> 'discriminant')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeDiscriminantToken')`;
      yield i`eat(<*Punctuator '{' balanced='}'> 'openCasesToken')`;
      yield i`eatMatch(<SwitchCase /(case|default)\b/> 'cases[]')`;
      yield i`eat(<*Punctuator '}' balancer> 'closeCasesToken')`;
    }
    *SwitchCase({
      intrinsicValue,
      ctx
    }) {
      switch (ctx.sourceTextFor(intrinsicValue)) {
        case 'case':
          yield i`eat(<*Keyword 'case'> 'sigilToken')`;
          yield i`eat(<Expression> 'condition')`;
          break;
        case 'default':
          yield i`eat(<*Keyword 'default'> 'sigilToken')`;
          yield i`eat(null 'condition')`;
          break;
        default:
          yield i`fail()`;
          break;
      }
      yield i`eat(<*Punctuator ':'> 'bodySeparatorToken')`;
      while (yield i`match(/./)`) yield i`eat(<Statement> 'statements[]')`;
    }
    *ForStatement() {
      yield i`eat(<*Keyword 'for'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration> 'init')`)) {
        yield i`eatMatch(<Expression> 'init')`;
      }
      yield i`eat(<*Punctuator ';'> 'testSeparatorToken')`;
      yield i`eatMatch(<Expression> 'test')`;
      yield i`eat(<*Punctuator ';'> 'updateSeparatorToken')`;
      yield i`eatMatch(<Expression> 'update')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *ForInStatement() {
      yield i`eat(<*Keyword 'for'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration> 'left')`)) {
        yield i`eatMatch(<Expression> 'left')`;
      }
      yield i`eat(<*Keyword 'in'> 'iterationSigilToken')`;
      yield i`eatMatch(<Expression> 'right')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *LabeledStatement() {
      yield i`eat(<*Identifier> 'label')`;
      yield i`eat(<*Puncuator ':'> 'sigilToken')`;
      yield i`eat(<*Statement> 'body')`;
    }
    *BreakStatement() {
      yield i`eat(<*Keyword 'break'> 'sigilToken')`;
      yield i`eatMatch(<*Identifier> 'label')`;
    }
    *ContinueStatement() {
      yield i`eat(<*Keyword 'continue'> 'sigilToken')`;
      yield i`eatMatch(<*Identifier> 'label')`;
    }
  };
};