/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./statement.macro.js#408176876d3cb9441efdc44e05fb36a9141898a7
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i } from '@bablr/boot';
import { AllowEmpty, CoveredBy, Node } from '@bablr/helpers/decorators';
export const mixin = Base => {
  var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _initProto;
  return _dec = CoveredBy('Statement'), _dec2 = CoveredBy('Statement'), _dec3 = CoveredBy('Statement'), _dec4 = CoveredBy('Statement'), _dec5 = CoveredBy('Statement'), _dec6 = CoveredBy('Statement'), _dec7 = CoveredBy('Statement'), _dec8 = CoveredBy('Statement'), _dec9 = CoveredBy('Statement'), _dec10 = CoveredBy('Statement'), _dec11 = CoveredBy('Statement'), class ES3StatementGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[Node, 2, "Program"], [Node, 2, "ExpressionStatement"], [[_dec, AllowEmpty, Node], 2, "EmptyStatement"], [[_dec2, Node], 2, "BlockStatement"], [[_dec3, Node], 2, "IfStatement"], [[_dec4, Node], 2, "WhileStatement"], [[_dec5, Node], 2, "DoWhileStatement"], [[_dec6, Node], 2, "SwitchStatement"], [Node, 2, "SwitchCase"], [[_dec7, Node], 2, "ForStatement"], [[_dec8, Node], 2, "ForInStatement"], [[_dec9, Node], 2, "LabeledStatement"], [[_dec10, Node], 2, "BreakStatement"], [[_dec11, Node], 2, "ContinueStatement"]], []).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *Program() {
      yield i`eat(<StatementList> 'body[]')`;
    }
    *StatementList() {
      do {
        yield i`eat(<Statement>)`;
      } while (yield i`eatMatch(<*~Punctuator ';'>)`);
    }
    *ExpressionStatement() {
      yield i`eat(<Expression> 'expression')`;
    }
    *Statement() {
      yield i`eat(<Any> null [
        <EmptyStatement /$/>
        <BlockStatement '{'>
        <IfStatement 'if'>
        <WhileStatement 'while'>
        <DoWhileStatement 'do'>
        <SwitchStatement 'switch'>
        <LoopStatement 'for'>
        <ExpressionStatement>
      ])`;
    }
    *EmptyStatement() {}
    *BlockStatement() {
      yield i`eat(<*Punctuator '{' balanced='}'> 'openToken')`;
      yield i`eat(<StatementList> 'body[]')`;
      yield i`eat(<*Punctuator '}' balancer> 'closeToken')`;
    }
    *IfStatement() {
      yield i`eat(<*Keyword 'if'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'consequent')`;
      if (yield i`eatMatch(<*Keyword 'else'> 'alternateSigilToken')`) {
        yield i`eat(<Statement> 'alternate')`;
      } else {
        yield i`eat(null 'alternate')`;
      }
    }
    *WhileStatement() {
      yield i`eat(<*Keyword 'while'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *DoWhileStatement() {
      yield i`eat(<*Keyword 'do'> 'sigilToken')`;
      yield i`eat(<Statement> 'body')`;
      yield i`eat(<*Keyword 'while'> 'footerSigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openFooterToken')`;
      yield i`eat(<Expression> 'test')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeFooterToken')`;
    }
    *SwitchStatement() {
      yield i`eat(<*Keyword 'switch'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openDiscriminantToken')`;
      yield i`eat(<Expression> 'discriminant')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeDiscriminantToken')`;
      yield i`eat(<*Punctuator '{' balanced='}'> 'openCasesToken')`;
      yield i`eatMatch(<SwitchCase /(case|default)\b/> 'cases[]')`;
      yield i`eat(<*Punctuator '}' balancer> 'closeCasesToken')`;
    }
    *SwitchCase({
      intrinsicValue,
      ctx
    }) {
      switch (ctx.sourceTextFor(intrinsicValue)) {
        case 'case':
          yield i`eat(<*Keyword 'case'> 'sigilToken')`;
          yield i`eat(<Expression> 'condition')`;
          break;
        case 'default':
          yield i`eat(<*Keyword 'default'> 'sigilToken')`;
          yield i`eat(null 'condition')`;
          break;
        default:
          yield i`fail()`;
          break;
      }
      yield i`eat(<*Punctuator ':'> 'bodySeparatorToken')`;
      while (yield i`match(/./)`) yield i`eat(<Statement> 'statements[]')`;
    }
    *LoopStatement() {
      // This might have been called ForStatement, but that name was already in use
      throw new Error('not implemented');
    }
    *ForStatement() {
      yield i`eat(<*Keyword 'for'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration> 'init')`)) {
        yield i`eatMatch(<Expression> 'init')`;
      }
      yield i`eat(<*Punctuator ';'> 'testSeparatorToken')`;
      yield i`eatMatch(<Expression> 'test')`;
      yield i`eat(<*Punctuator ';'> 'updateSeparatorToken')`;
      yield i`eatMatch(<Expression> 'update')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *ForInStatement() {
      yield i`eat(<*Keyword 'for'> 'sigilToken')`;
      yield i`eat(<*Punctuator '(' balanced=')'> 'openHeaderToken')`;
      if (!(yield i`eatMatch(<VariableDeclaration> 'left')`)) {
        yield i`eatMatch(<Expression> 'left')`;
      }
      yield i`eat(<*Keyword 'in'> 'iterationSigilToken')`;
      yield i`eatMatch(<Expression> 'right')`;
      yield i`eat(<*Punctuator ')' balancer> 'closeHeaderToken')`;
      yield i`eat(<Statement> 'body')`;
    }
    *LabeledStatement() {
      yield i`eat(<*Identifier> 'label')`;
      yield i`eat(<*Puncuator ':'> 'sigilToken')`;
      yield i`eat(<*Statement> 'body')`;
    }
    *BreakStatement() {
      yield i`eat(<*Keyword 'break'> 'sigilToken')`;
      yield i`eatMatch(<*Identifier> 'label')`;
    }
    *ContinueStatement() {
      yield i`eat(<*Keyword 'continue'> 'sigilToken')`;
      yield i`eatMatch(<*Identifier> 'label')`;
    }
  };
};