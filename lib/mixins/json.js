/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./json.macro.js#ef2f84415658b0967521250a537705630f6e56b6
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i } from '@bablr/boot';
import { Node, CoveredBy, Attributes, AllowEmpty } from '@bablr/helpers/decorators';
import { buildString } from '@bablr/agast-vm-helpers';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0',
  '\\': '\\',
  '/': '/'
}));
export const mixin = Base => {
  let _initProto, _BooleanDecs, _NullDecs, _ArrayDecs, _ObjectDecs, _StringDecs, _EscapeSequenceDecs;
  return class ES3JSONGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[_BooleanDecs, 2, "Boolean"], [_NullDecs, 2, "Null"], [_ArrayDecs, 2, "Array"], [_ObjectDecs, 2, "Object"], [Node, 2, "Property"], [_StringDecs, 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [_EscapeSequenceDecs, 2, "EscapeSequence"], [Node, 2, "EscapeCode"]], [], 0, void 0, Base).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *[(_BooleanDecs = [CoveredBy('Expression'), Node], _NullDecs = [CoveredBy('Expression'), Node], _ArrayDecs = [CoveredBy('Expression'), Node], _ObjectDecs = [CoveredBy('Expression'), Node], _StringDecs = [CoveredBy('Language'), Node], _EscapeSequenceDecs = [Attributes(['cooked']), Node], "Boolean")]() {
      yield i`eat(/true|false/)`;
    }
    *Null() {
      yield i`eat('null')`;
    }
    *Array() {
      yield i`eat(<~*Punctuator '[' balanced=']' /> 'open')`;
      yield i`eat(<List /> 'elements[]' {
      element: <Expression />
      separator: <~*Punctuator ',' />
      allowTrailingSeparator: false
    })`;
      yield i`eat(<~*Punctuator ']' balancer /> 'close')`;
    }
    *Object() {
      yield i`eat(<~*Punctuator '{' balanced='}' /> 'open')`;
      yield i`eat(<List /> 'properties[]' {
      element: <Property />
      separator: <~*Punctuator ',' />
      allowTrailingSeparator: false
    })`;
      yield i`eat(<~*Punctuator '}' balancer /> 'close')`;
    }
    *Property() {
      yield i`eat(<String /> 'key')`;
      yield i`eat(<~*Punctuator ':' /> 'mapOperator')`;
      yield i`eat(<Expression /> 'value')`;
    }
    *String({
      ctx
    }) {
      let q = yield i`match(/['"]/)`;
      if (!q) yield i`fail()`;
      const q_ = ctx.sourceTextFor(q);
      yield q_ === "'" ? i`eat(<~*Punctuator "'" balanced="'" balancedSpan='String:Single' /> 'open')` : i`eat(<~*Punctuator '"' balanced='"' balancedSpan='String:Double' /> 'open')`;
      yield i`eat(<*StringContent /> 'content')`;
      yield q_ === "'" ? i`eat(<~*Punctuator "'" balancer /> 'close')` : i`eat(<~*Punctuator '"' balancer /> 'close')`;
    }
    *StringContent({
      state: {
        span
      }
    }) {
      let esc, lit;
      do {
        esc = (yield i`match('\\')`) && (yield i`eat(<@EscapeSequence />)`);
        lit = span === 'String:Single' ? yield i`eatMatch(/[^\r\n\\']+/)` : yield i`eatMatch(/[^\r\n\\"]+/)`;
      } while (esc || lit);
    }
    *EscapeSequence({
      state: {
        span
      },
      ctx
    }) {
      if (!span.startsWith('String')) {
        yield i`fail()`;
      }
      yield i`eat(<~*Punctuator '\\' openSpan='Escape' /> 'escape')`;
      let match, cooked;
      if (match = span === 'String:Single' ? yield i`match(/[\\/nrt0']/)` : yield i`match(/[\\/nrt0"]/)`) {
        const match_ = ctx.sourceTextFor(match);
        yield i`eat(<~*Keyword ${buildString(match_)} closeSpan='Escape' /> 'value')`;
        cooked = escapables.get(match_) || match_;
      } else if (yield i`match('u')`) {
        const codeNode = yield i`eat(<EscapeCode closeSpan='Escape' /> 'value')`;
        cooked = parseInt(codeNode.properties.digits.map(digit => ctx.sourceTextFor(digit)).join(''), 16);
      } else {
        yield i`fail()`;
      }
      yield i`bindAttribute(cooked ${buildString(cooked.toString(10))})`;
    }
    *EscapeCode() {
      if (yield i`eatMatch(<~*Keyword 'u' /> 'type')`) {
        if (yield i`eatMatch(<~*Punctuator '{' /> 'open')`) {
          yield i`eat(<Digits /> 'digits[]')`;
          yield i`eat(<~*Punctuator '}' /> 'close')`;
        } else {
          yield i`eat(<Digits /\d{4}/ /> 'digits[]')`;
          yield i`eat(null 'close')`;
        }
      }
    }
  };
};