/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./json.macro.js#e8822d91a55e9798cd5ac7ed729df91818cfd60f
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { i } from '@bablr/boot';
import { Node, CoveredBy, Attributes, AllowEmpty } from '@bablr/helpers/decorators';
import { buildString } from '@bablr/agast-vm-helpers';
export const escapables = new Map(Object.entries({
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0',
  '\\': '\\',
  '/': '/'
}));
export const mixin = Base => {
  var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _initProto;
  return _dec = CoveredBy('Expression'), _dec2 = CoveredBy('Expression'), _dec3 = CoveredBy('Expression'), _dec4 = CoveredBy('Expression'), _dec5 = CoveredBy('Language'), _dec6 = Attributes(['cooked']), class ES3JSONGrammar extends Base {
    static {
      [_initProto] = _applyDecs(this, [[[_dec, Node], 2, "Boolean"], [[_dec2, Node], 2, "Null"], [[_dec3, Node], 2, "Array"], [[_dec4, Node], 2, "Object"], [Node, 2, "Property"], [[_dec5, Node], 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [[_dec6, Node], 2, "EscapeSequence"], [Node, 2, "EscapeCode"]], []).e;
    }
    constructor(...args) {
      super(...args);
      _initProto(this);
    }
    *Boolean() {
      yield i`eat(/true|false/)`;
    }
    *Null() {
      yield i`eat('null')`;
    }
    *Array() {
      yield i`eat(<~*Punctuator '[' balanced=']'> 'open')`;
      yield i`eat(<List> 'elements[]' {
      element: <Expression>
      separator: <~*Punctuator ','>
      allowTrailingSeparator: false
    })`;
      yield i`eat(<~*Punctuator ']' balancer> 'close')`;
    }
    *Object() {
      yield i`eat(<~*Punctuator '{' balanced='}'> 'open')`;
      yield i`eat(<List> 'properties[]' {
      element: <Property>
      separator: <~*Punctuator ','>
      allowTrailingSeparator: false
    })`;
      yield i`eat(<~*Punctuator '}' balancer> 'close')`;
    }
    *Property() {
      yield i`eat(<String> 'key')`;
      yield i`eat(<~*Punctuator ':'> 'mapOperator')`;
      yield i`eat(<Expression> 'value')`;
    }
    *String({
      ctx
    }) {
      let q = yield i`match(/['"]/)`;
      if (!q) yield i`fail()`;
      const q_ = ctx.sourceTextFor(q);
      yield q_ === "'" ? i`eat(<~*Punctuator "'" balanced="'" balancedSpan='String:Single'> 'open')` : i`eat(<~*Punctuator '"' balanced='"' balancedSpan='String:Double'> 'open')`;
      yield i`eat(<*StringContent> 'content')`;
      yield q_ === "'" ? i`eat(<~*Punctuator "'" balancer> 'close')` : i`eat(<~*Punctuator '"' balancer> 'close')`;
    }
    *StringContent({
      state: {
        span
      }
    }) {
      let esc, lit;
      do {
        esc = (yield i`match('\\')`) && (yield i`eat(<@EscapeSequence>)`);
        lit = span === 'String:Single' ? yield i`eatMatch(/[^\r\n\\']+/)` : yield i`eatMatch(/[^\r\n\\"]+/)`;
      } while (esc || lit);
    }
    *EscapeSequence({
      state: {
        span
      },
      ctx
    }) {
      if (!span.startsWith('String')) {
        yield i`fail()`;
      }
      yield i`eat(<~*Punctuator '\\'> 'escape')`;
      let match, cooked;
      if (match = span === 'String:Single' ? yield i`match(/[\\/nrt0']/)` : yield i`match(/[\\/nrt0"]/)`) {
        const match_ = ctx.sourceTextFor(match);
        yield i`eat(<~*Keyword ${buildString(match_)}> 'value')`;
        cooked = escapables.get(match_) || match_;
      } else if (yield i`match('u')`) {
        const codeNode = yield i`eat(<EscapeCode> 'value')`;
        cooked = parseInt(ctx.getProperty(codeNode, 'digits').map(digit => ctx.sourceTextFor(digit)).join(''), 16);
      } else {
        yield i`fail()`;
      }
      yield i`bindAttribute(cooked ${buildString(cooked.toString(10))})`;
    }
    *EscapeCode() {
      if (yield i`eatMatch(<~*Keyword 'u'> 'type')`) {
        if (yield i`eatMatch(<~*Punctuator '{'> 'open')`) {
          yield i`eat(<Digits> 'digits[]')`;
          yield i`eat(<~*Punctuator '}'> 'close')`;
        } else {
          yield i`eat(<Digits /\d{4}/> 'digits[]')`;
          yield i`eat(null 'close')`;
        }
      }
    }
  };
};